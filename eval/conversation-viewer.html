<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0">
  <title>Storybook MCP Eval Conversation Viewer</title>
  <link rel="stylesheet" href="https://esm.sh/highlight.js@11.9.0/styles/github-dark-dimmed.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      background: #f5f5f5;
      color: #333;
      line-height: 1.6;
      padding: 2rem;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 2rem;
      color: #1a1a1a;
    }

    .upload-section {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin-bottom: 2rem;
    }

    .upload-section p {
      margin-bottom: 1rem;
      color: #666;
      font-size: 0.875rem;
    }

    .upload-section code {
      background: #f0f0f0;
      padding: 0.125rem 0.375rem;
      border-radius: 3px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
    }

    .upload-button {
      background: #0066cc;
      color: white;
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    .upload-button:hover {
      background: #0052a3;
    }

    input[type="file"] {
      width: 100%;
      padding: 1rem;
      border: 2px dashed #0066cc;
      border-radius: 6px;
      background: #f8fbff;
      cursor: pointer;
      font-size: 0.875rem;
    }

    input[type="file"]::-webkit-file-upload-button {
      background: #0066cc;
      color: white;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 1rem;
    }

    input[type="file"]::-webkit-file-upload-button:hover {
      background: #0052a3;
    }

    .metadata {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin-bottom: 2rem;
      display: none;
    }

    .metadata.visible {
      display: block;
    }

    .metadata h2 {
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
      color: #1a1a1a;
    }

    .metadata-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .metadata-card {
      background: #f9f9f9;
      padding: 1rem;
      border-radius: 6px;
      border-left: 4px solid #0066cc;
    }

    .metadata-card h3 {
      font-size: 0.875rem;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .metadata-card .value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #1a1a1a;
    }

    .metadata-card .subvalue {
      font-size: 0.875rem;
      color: #666;
      margin-top: 0.25rem;
    }

    .mcp-servers {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .mcp-server {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: #e8f4f8;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-size: 0.875rem;
    }

    .mcp-server.connected::before {
      content: '●';
      color: #00aa00;
    }

    .mcp-server.disconnected::before {
      content: '●';
      color: #cc0000;
    }

    .conversation {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .turn {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .turn.mcp-tool {
      background: #e8f4f8;
    }

    .turn-header {
      padding: 1rem 1.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 1rem;
      transition: background 0.2s;
    }

    .turn-header:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    .turn.mcp-tool .turn-header:hover {
      background: rgba(0, 102, 204, 0.05);
    }

    .turn-type {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .turn-type.assistant {
      background: #e3f2fd;
      color: #1976d2;
    }

    .turn-type.user {
      background: #f3e5f5;
      color: #7b1fa2;
    }

    .turn-type.system {
      background: #e8eaf6;
      color: #3949ab;
    }

    .turn-type.result {
      background: #e8f5e9;
      color: #388e3c;
    }

    .turn-type.tool-call {
      background: #fff3e0;
      color: #e65100;
    }

    .mcp-badge {
      background: #0066cc;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .turn-title {
      font-weight: 500;
      color: #1a1a1a;
    }

    .turn-subtitle {
      font-size: 0.875rem;
      color: #666;
      font-family: 'Monaco', 'Courier New', monospace;
      margin-left: 0.5rem;
    }

    .turn-spacer {
      flex: 1;
    }

    .token-count {
      font-size: 0.875rem;
      color: #999;
      font-family: 'Monaco', 'Courier New', monospace;
      white-space: nowrap;
      margin-left: 1rem;
    }

    .elapsed-time {
      text-align: center;
      color: #999;
      font-size: 1rem;
      font-family: 'Monaco', 'Courier New', monospace;
      padding: 0;
      margin: 0;
    }

    .todo-list {
      color: #333;
      font-size: 0.875rem;
      padding: 0.75rem 0;
      margin: 0.5rem 0;
    }

    .todo-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0;
    }

    .todo-item input[type="checkbox"] {
      margin: 0;
      cursor: default;
      pointer-events: none;
    }

    .todo-text {
      flex: 1;
    }

    .turn-content {
      padding: 0 1.5rem 1.5rem 1.5rem;
      display: none;
    }

    .turn.expanded .turn-content {
      display: block;
    }

    .turn.expanded .turn-header .chevron {
      transform: rotate(90deg);
    }

    .chevron {
      width: 0;
      height: 0;
      border-left: 6px solid #666;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      transition: transform 0.2s;
    }

    .content-section {
      margin-bottom: 1rem;
    }

    .content-section:last-child {
      margin-bottom: 0;
    }

    .code-block-wrapper {
      position: relative;
      margin-bottom: 0.5rem;
    }

    .code-block-wrapper:last-child {
      margin-bottom: 0;
    }

    .content-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: #666;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
    }

    .code-block-wrapper pre {
      background: #f9f9f9;
      padding: 0;
      border-radius: 4px;
      border-left: 3px solid #ddd;
      margin: 0;
      overflow-x: auto;
    }

    .code-block-wrapper code {
      display: block;
      padding: 1rem;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      white-space: pre-wrap;
      word-break: break-word;
      tab-size: 2;
    }

    /* Override hljs background to match our style */
    .code-block-wrapper pre.hljs {
      background: #f9f9f9;
    }

    .code-block-wrapper pre.error {
      background: #ffebee;
      border-left-color: #c62828;
    }

    .code-block-wrapper pre.error code {
      color: #c62828;
    }

    .code-block-wrapper pre.truncated {
      max-height: 200px;
      overflow: hidden;
      position: relative;
      padding-bottom: 2.5rem;
    }

    .code-block-wrapper pre.truncated::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(transparent, #0d1117);
    }

    .show-more {
      position: absolute;
      bottom: 0.5rem;
      right: 0.5rem;
      color: #58a6ff;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 600;
      background: rgba(13, 17, 23, 0.9);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .show-more:hover {
      text-decoration: underline;
    }

    .hidden {
      display: none;
    }

    .error {
      background: #ffebee;
      color: #c62828;
      padding: 1rem;
      border-radius: 6px;
      margin-top: 1rem;
    }

    .turn.prompt-turn {
      background: #fffbeb;
      border: 2px solid #fbbf24;
    }

    .turn.prompt-turn .turn-header:hover {
      background: rgba(251, 191, 36, 0.1);
    }

    .turn.prompt-turn .code-block-wrapper pre {
      max-height: none !important;
    }

    .turn.prompt-turn .code-block-wrapper pre.truncated {
      max-height: none;
      overflow: visible;
      padding-bottom: 1rem;
    }

    .turn.prompt-turn .code-block-wrapper pre.truncated::after {
      display: none;
    }

    .turn.prompt-turn .show-more {
      display: none;
    }

    .turn-type.prompt {
      background: #fef3c7;
      color: #92400e;
    }

    .drop-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 102, 204, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      pointer-events: none;
    }

    .drop-overlay.visible {
      display: flex;
    }

    .drop-overlay-text {
      color: white;
      font-size: 2rem;
      font-weight: 600;
      text-align: center;
      padding: 2rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      border: 3px dashed white;
    }
  </style>
</head>

<body>
  <div class="drop-overlay" id="drop-overlay">
    <div class="drop-overlay-text">Drop to load conversation</div>
  </div>

  <div class="container">
    <h1>Storybook MCP Eval Conversation Viewer</h1>

    <div class="upload-section">
      <p>Select a <code>full-conversation.js</code> file from an experiment's <code>results</code> directory:</p>
      <input type="file" id="file-input" accept=".js">
      <div id="error-message"></div>
    </div>

    <div id="metadata" class="metadata"></div>
    <div id="conversation" class="conversation"></div>
  </div>

  <script type="module">
    import hljs from 'https://esm.sh/highlight.js@11.9.0';

    const fileInput = document.getElementById('file-input');
    const errorMessage = document.getElementById('error-message');
    const metadataEl = document.getElementById('metadata');
    const conversationEl = document.getElementById('conversation');
    const dropOverlay = document.getElementById('drop-overlay');

    let conversationData = null;
    let promptData = null;
    let promptTokenCount = 0;
    let promptCost = 0;

    // Drag and drop handling
    let dragCounter = 0;

    document.body.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      if (dragCounter === 1) {
        dropOverlay.classList.add('visible');
      }
    });

    document.body.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        dropOverlay.classList.remove('visible');
      }
    });

    document.body.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.body.addEventListener('drop', (e) => {
      e.preventDefault();
      dragCounter = 0;
      dropOverlay.classList.remove('visible');

      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.name.endsWith('.js')) {
          const reader = new FileReader();
          reader.onload = (e) => loadConversationData(e.target.result, false);
          reader.readAsText(file);
        } else {
          showError('Please drop a .js file');
        }
      }
    });

    // Load conversation from file content or URL
    async function loadConversationData(source, isUrl = false) {
      const { promise, resolve, reject } = Promise.withResolvers();
      globalThis.loadConversation = resolve;

      const script = document.createElement('script');
      script.onerror = () => reject(new Error('Failed to load conversation file'));
      
      if (isUrl) {
        script.src = source;
      } else {
        // Wrap in IIFE to avoid scope conflicts
        script.textContent = `(function() { ${source} })();`;
      }
      
      document.head.appendChild(script);

      try {
        const { prompt, messages, promptTokenCount: tokens, promptCost: cost } = await promise;
        conversationData = messages;
        promptData = prompt;
        promptTokenCount = tokens || 0;
        promptCost = cost || 0;
        
        renderConversation();
      } catch (err) {
        showError('Invalid conversation file: ' + err.message);
      } finally {
        document.head.removeChild(script);
      }
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => loadConversationData(e.target.result, false);
      reader.readAsText(file);
    });

    // Check for path query parameter
    const pathParam = new URLSearchParams(window.location.search).get('path');
    if (pathParam) {
      loadConversationData(pathParam, true);
    }

    function showError(message) {
      errorMessage.innerHTML = `<div class="error">${message}</div>`;
    }

    function renderConversation() {
      if (!conversationData || !Array.isArray(conversationData)) {
        showError('Invalid conversation data');
        return;
      }

      errorMessage.innerHTML = '';
      renderMetadata();
      renderPrompt();
      renderTurns();
    }

    function renderMetadata() {
      const systemTurn = conversationData.find(t => t.type === 'system');
      const resultTurn = conversationData.find(t => t.type === 'result');

      if (!systemTurn && !resultTurn) return;

      const cards = [];

      if (systemTurn) {
        cards.push({
          title: 'Model',
          value: systemTurn.model || 'N/A',
          subvalue: systemTurn.claude_code_version ? `Claude Code ${systemTurn.claude_code_version}` : ''
        });

        if (systemTurn.tools) {
          const mcpTools = systemTurn.tools.filter(t => t.startsWith('mcp__'));
          cards.push({
            title: 'Available Tools',
            value: systemTurn.tools.length,
            subvalue: mcpTools.length > 0 ? `${mcpTools.length} MCP tools` : ''
          });
        }

        if (systemTurn.mcp_servers?.length > 0) {
          cards.push({
            title: 'MCP Servers',
            html: `<div class="mcp-servers">${systemTurn.mcp_servers.map(s => 
              `<div class="mcp-server ${s.status}">${s.name}</div>`
            ).join('')}</div>`
          });
        }
      }

      if (resultTurn) {
        if (resultTurn.duration_ms !== undefined) {
          cards.push({
            title: 'Duration',
            value: `${(resultTurn.duration_ms / 1000).toFixed(2)}s`,
            subvalue: resultTurn.duration_api_ms ? `API: ${(resultTurn.duration_api_ms / 1000).toFixed(2)}s` : ''
          });
        }

        if (resultTurn.num_turns !== undefined) {
          cards.push({
            title: 'Turns',
            value: resultTurn.num_turns
          });
        }

        if (resultTurn.total_cost_usd !== undefined) {
          cards.push({
            title: 'Total Cost',
            value: `$${resultTurn.total_cost_usd.toFixed(4)}`
          });
        }
      }

      const cardsHtml = cards.map(card => `
        <div class="metadata-card">
          <h3>${card.title}</h3>
          ${card.html || `
            <div class="value">${card.value}</div>
            ${card.subvalue ? `<div class="subvalue">${card.subvalue}</div>` : ''}
          `}
        </div>
      `).join('');

      metadataEl.innerHTML = `<h2>Conversation Metadata</h2><div class="metadata-grid">${cardsHtml}</div>`;
      metadataEl.classList.add('visible');
    }

    function renderPrompt() {
      if (!promptData) return;

      const tokenCostHtml = formatTokenCost(promptTokenCount, promptCost);

      conversationEl.innerHTML = `
        <div class="turn prompt-turn" data-index="-1">
          <div class="turn-header">
            <div class="chevron"></div>
            <span class="turn-type prompt">Prompt</span>
            <span class="turn-title">User Prompt</span>
            ${tokenCostHtml}
          </div>
          <div class="turn-content">
            ${renderContentSection('Prompt', promptData)}
          </div>
        </div>
      `;
    }

    function renderTurns() {
      const turns = conversationData.filter(t =>
        ['assistant', 'user', 'system', 'result'].includes(t.type)
      );

      const groupedTurns = groupToolCallsWithResults(turns);
      const html = groupedTurns.map((group, index) => {
        const isTodoWrite = group.toolCall?.message?.content?.find(c => 
          c.type === 'tool_use' && c.name === 'TodoWrite'
        );
        
        if (isTodoWrite) {
          return renderTodoList(group.toolCall, index);
        }
        
        let turnHtml = '';
        
        // Add elapsed time before turn (skip first)
        if (index > 0) {
          const currentTurn = group.toolCall || group.turn;
          const elapsedMs = currentTurn.ms;
          if (elapsedMs >= 50) {
            turnHtml += `<div class="elapsed-time">${(elapsedMs / 1000).toFixed(1)}s</div>`;
          }
        }
        
        turnHtml += group.toolCall 
          ? renderToolCallGroup(group.toolCall, group.toolResult, index)
          : renderTurn(group.turn, index);
        
        return turnHtml;
      }).join('');

      conversationEl.innerHTML += html;

      // Set indeterminate state for in-progress todos
      document.querySelectorAll('input[type="checkbox"][data-indeterminate="true"]').forEach(cb => {
        cb.indeterminate = true;
      });

      // Syntax highlight lazily
      requestIdleCallback(() => hljs.highlightAll(), { timeout: 2000 });

      // Add event listeners
      document.querySelectorAll('.turn-header').forEach(header => {
        header.addEventListener('click', () => header.parentElement.classList.toggle('expanded'));
      });

      document.querySelectorAll('.show-more').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const pre = btn.previousElementSibling;
          const isExpanded = !pre.classList.contains('truncated');
          pre.classList.toggle('truncated');
          btn.textContent = isExpanded ? 'Show more' : 'Show less';
        });
      });
    }

    function groupToolCallsWithResults(turns) {
      const grouped = [];
      const usedResultIndices = new Set();

      for (let i = 0; i < turns.length; i++) {
        if (usedResultIndices.has(i)) continue;

        const turn = turns[i];
        const toolUseContent = turn.type === 'assistant' && 
          turn.message?.content?.find(c => c.type === 'tool_use');

        if (toolUseContent) {
          const toolUseId = toolUseContent.id;
          const resultIndex = turns.findIndex((t, j) => 
            j > i && t.type === 'user' && 
            t.message?.content?.some(c => c.type === 'tool_result' && c.tool_use_id === toolUseId)
          );

          if (resultIndex !== -1) {
            grouped.push({ toolCall: turn, toolResult: turns[resultIndex] });
            usedResultIndices.add(resultIndex);
            continue;
          }
        }

        grouped.push({ turn });
      }

      return grouped;
    }

    function renderTodoList(toolCall, index) {
      const toolUse = toolCall.message.content.find(c => c.type === 'tool_use');
      if (!toolUse?.input?.todos) return '';

      const todoId = `todo-${index}`;
      return `<div class="todo-list">${toolUse.input.todos.map((todo, i) => {
        const status = todo.status || 'pending';
        const checked = status === 'completed' ? 'checked' : '';
        const indeterminate = status === 'in_progress';
        return `
          <div class="todo-item">
            <input type="checkbox" id="${todoId}-${i}" ${checked} data-indeterminate="${indeterminate}">
            <label for="${todoId}-${i}" class="todo-text">${escapeHtml(todo.content)}</label>
          </div>
        `;
      }).join('')}</div>`;
    }

    function renderToolCallGroup(toolCall, toolResult, index) {
      const toolUse = toolCall.message.content.find(c => c.type === 'tool_use');
      const toolName = toolUse?.name || 'Unknown Tool';
      const isMCP = toolName.startsWith('mcp__');

      const additionalInfo = extractToolAdditionalInfo(toolUse, toolName);
      const inputHtml = renderToolInput(toolUse, toolName);
      const outputHtml = renderToolOutput(toolResult, isMCP);
      const tokenCostHtml = formatToolTokenCost(toolCall, toolResult);

      return `
        <div class="turn ${isMCP ? 'mcp-tool' : ''}" data-index="${index}">
          <div class="turn-header">
            <div class="chevron"></div>
            <span class="turn-type tool-call">tool call</span>
            ${isMCP ? '<span class="mcp-badge">MCP</span>' : ''}
            <span class="turn-title">${toolName}</span>
            ${additionalInfo ? `<span class="turn-subtitle">${escapeHtml(additionalInfo)}</span>` : ''}
            ${tokenCostHtml}
          </div>
          <div class="turn-content">
            ${inputHtml}
            ${outputHtml}
          </div>
        </div>
      `;
    }

    function extractToolAdditionalInfo(toolUse, toolName) {
      if (!toolUse?.input) return '';

      if (['Read', 'Write', 'Edit'].includes(toolName)) {
        const fullPath = toolUse.input.file_path || toolUse.input.path;
        if (fullPath) {
          const systemTurn = conversationData.find(t => t.type === 'system');
          const cwd = systemTurn?.cwd || '';
          return cwd && fullPath.startsWith(cwd)
            ? fullPath.substring(cwd.length).replace(/^\//, '')
            : fullPath;
        }
      }

      if (toolName === 'Glob' && toolUse.input.pattern) {
        return toolUse.input.pattern;
      }

      if (toolName === 'Bash' && toolUse.input.command) {
        const cmd = toolUse.input.command;
        return cmd.length > 80 ? cmd.slice(0, 80) + '...' : cmd;
      }

      return '';
    }

    function renderToolInput(toolUse, toolName) {
      if (!toolUse?.input) return '';

      if (toolName === 'Write' && toolUse.input.file_path && toolUse.input.content) {
        return renderFileContent(toolUse.input.file_path, toolUse.input.content, 'typescript');
      }

      if (toolName === 'Edit' && toolUse.input.file_path && toolUse.input.old_string && toolUse.input.new_string) {
        return renderFileDiff(toolUse.input.file_path, toolUse.input.old_string, toolUse.input.new_string);
      }

      return renderContentSection('Input', formatJsonWithPreservedWhitespace(toolUse.input));
    }

    function renderFileContent(filePath, content, language) {
      const shouldTruncate = content.length > 500;
      return `
        <div class="content-section">
          <div class="content-label">File Path</div>
          <code style="background: #f9f9f9; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">${escapeHtml(filePath)}</code>
        </div>
        <div class="content-section">
          <div class="content-label">Content</div>
          <div class="code-block-wrapper">
            <pre class="${shouldTruncate ? 'truncated' : ''}"><code class="language-${language}">${escapeHtml(content)}</code></pre>
            ${shouldTruncate ? '<div class="show-more">Show more</div>' : ''}
          </div>
        </div>
      `;
    }

    function renderFileDiff(filePath, oldString, newString) {
      const diff = `--- a/${filePath}
+++ b/${filePath}
@@ -1,${oldString.split('\n').length} +1,${newString.split('\n').length} @@
${oldString.split('\n').map(line => '-' + line).join('\n')}
${newString.split('\n').map(line => '+' + line).join('\n')}`;
      
      const shouldTruncate = diff.length > 500;
      return `
        <div class="content-section">
          <div class="content-label">File Path</div>
          <code style="background: #f9f9f9; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">${escapeHtml(filePath)}</code>
        </div>
        <div class="content-section">
          <div class="content-label">Diff</div>
          <div class="code-block-wrapper">
            <pre class="${shouldTruncate ? 'truncated' : ''}"><code class="language-diff">${escapeHtml(diff)}</code></pre>
            ${shouldTruncate ? '<div class="show-more">Show more</div>' : ''}
          </div>
        </div>
      `;
    }

    function renderToolOutput(toolResult, isMCP) {
      const toolResultContent = toolResult.message.content.find(c => c.type === 'tool_result');
      if (!toolResultContent) return '';

      if (isMCP) {
        try {
          const content = typeof toolResultContent.content === 'string'
            ? JSON.parse(toolResultContent.content)
            : toolResultContent.content;

          if (Array.isArray(content)) {
            return `<div class="content-section"><div class="content-label">Output</div>${
              content.map(item => {
                if (item.type !== 'text' || !item.text) return '';
                const shouldTruncate = item.text.length > 500;
                return `
                  <div class="code-block-wrapper">
                    <pre class="${item.isError ? 'error ' : ''}${shouldTruncate ? 'truncated' : ''}"><code>${escapeHtml(item.text)}</code></pre>
                    ${shouldTruncate ? '<div class="show-more">Show more</div>' : ''}
                  </div>
                `;
              }).join('')
            }</div>`;
          }
        } catch (e) {
          // Fall through to default rendering
        }
      }

      return renderContentSection('Output', toolResultContent.content);
    }

    function formatToolTokenCost(toolCall, toolResult) {
      const parts = [];
      
      if (toolCall.tokenCount !== undefined) {
        const cost = toolCall.costUSD !== undefined ? ` ($${toolCall.costUSD.toFixed(4)})` : '';
        parts.push(`${toolCall.tokenCount.toLocaleString()} tokens${cost}`);
      }
      
      if (toolResult?.tokenCount !== undefined) {
        const cost = toolResult.costUSD !== undefined ? ` ($${toolResult.costUSD.toFixed(4)})` : '';
        parts.push(`${toolResult.tokenCount.toLocaleString()} tokens${cost}`);
      }
      
      return parts.length > 0
        ? `<span class="turn-spacer"></span><span class="token-count">${parts.join(' + ')}</span>`
        : '';
    }

    function renderTurn(turn, index) {
      const isMCP = turn.type === 'assistant' && turn.message?.content?.some(c =>
        c.type === 'tool_use' && c.name?.startsWith('mcp__')
      );

      const title = getTurnTitle(turn);
      const content = turn.message?.content
        ? renderTurnContent(turn.message.content)
        : (turn.type === 'system' || turn.type === 'result')
          ? renderSystemOrResult(turn)
          : '';
      const tokenCostHtml = formatTokenCost(turn.tokenCount, turn.costUSD);

      return `
        <div class="turn ${isMCP ? 'mcp-tool' : ''}" data-index="${index}">
          <div class="turn-header">
            <div class="chevron"></div>
            <span class="turn-type ${turn.type}">${turn.type}</span>
            ${isMCP ? '<span class="mcp-badge">MCP</span>' : ''}
            <span class="turn-title">${title}</span>
            ${tokenCostHtml}
          </div>
          <div class="turn-content">
            ${content}
          </div>
        </div>
      `;
    }

    function getTurnTitle(turn) {
      if (turn.type === 'assistant' && turn.message?.content) {
        const toolUse = turn.message.content.find(c => c.type === 'tool_use');
        if (toolUse) return toolUse.name;
        
        const text = turn.message.content.find(c => c.type === 'text');
        if (text) return truncateText(text.text, 80);
      }

      if (turn.type === 'user' && turn.message?.content) {
        const toolResult = turn.message.content.find(c => c.type === 'tool_result');
        if (toolResult) return `Result: ${toolResult.tool_use_id}`;
      }

      return turn.subtype || turn.type;
    }

    function renderTurnContent(content) {
      if (!Array.isArray(content)) return '';

      return content.map(item => {
        if (item.type === 'text') {
          return renderContentSection('Text', item.text);
        }
        if (item.type === 'tool_use') {
          let html = renderContentSection('Tool', item.name);
          if (item.input) {
            html += renderContentSection('Input', formatJsonWithPreservedWhitespace(item.input));
          }
          return html;
        }
        if (item.type === 'tool_result') {
          return renderContentSection('Result', item.content);
        }
        return '';
      }).join('');
    }

    function renderSystemOrResult(turn) {
      const data = { ...turn };
      delete data.type;
      delete data.ms;
      delete data.uuid;
      delete data.session_id;
      delete data.parent_tool_use_id;
      delete data.tokenCount;
      delete data.costUSD;

      return renderContentSection('Data', formatJsonWithPreservedWhitespace(data));
    }

    function renderContentSection(label, value) {
      if (!value) return '';

      const valueStr = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
      const shouldTruncate = valueStr.length > 500;
      const languageClass = label === 'Text' ? 'language-markdown' : '';

      return `
        <div class="content-section">
          <div class="content-label">${label}</div>
          <div class="code-block-wrapper">
            <pre class="${shouldTruncate ? 'truncated' : ''}"><code class="${languageClass}">${escapeHtml(valueStr)}</code></pre>
            ${shouldTruncate ? '<div class="show-more">Show more</div>' : ''}
          </div>
        </div>
      `;
    }

    function formatTokenCost(tokens, cost) {
      if (tokens === undefined) return '';
      const costStr = cost !== undefined ? ` ($${cost.toFixed(4)})` : '';
      return `<span class="turn-spacer"></span><span class="token-count">${tokens.toLocaleString()} tokens${costStr}</span>`;
    }

    function truncateText(text, maxLength) {
      return text.length <= maxLength ? text : text.substring(0, maxLength) + '...';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatJsonWithPreservedWhitespace(obj) {
      return JSON.stringify(obj, null, 2)
        .replace(/\\\\n/g, '\\n')
        .replace(/\\n/g, '\n')
        .replace(/\\\\t/g, '\\t')
        .replace(/\\t/g, '\t');
    }
  </script>
</body>

</html>
